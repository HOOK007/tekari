#include "tekari/Metadata.h"

#include <sstream>
#include <vector>
#include <utility>
#include <functional>

TEKARI_NAMESPACE_BEGIN

using namespace std;

Metadata::Metadata()
:   mIsSpectral(false)
,   mInPhi(0.0f)
,   mInTheta(0.0f)
,   mSampleName("Untilted")
,   mPointsInFile(-1)
,   mDataPointsPerLoop(-1)
{}

void Metadata::addLine(const string& line)
{
    mRawMetadata.push_back(line.substr(0, line.length()-1));
}

void Metadata::initInfos()
{
    const string* line;

    mIsSpectral = findLineStartingWith("#spectral data generated by") != nullptr;

    vector<pair<string, function<void(const string&, const string*)>>> parsingFuncs =
    {
        make_pair("#number of datapoints per loop in file:", [this](const string &keyword, const string* line) {
            sscanf(line->c_str() + keyword.length(), "%d", &mDataPointsPerLoop);
        }),
        make_pair("#inphi", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInPhi); }),
        make_pair("#phi_in", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInPhi); }),
        make_pair("#intheta", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInTheta); }),
        make_pair("#theta_in", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInTheta); }),
        make_pair("#datapoints_in_file", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%d", &mPointsInFile); }),
        make_pair("#sample_name", [this](const string &, const string* line) { mSampleName = stripQuoteMarks(line->substr(13)); }),
    };

    for (const auto& p : parsingFuncs)
    {
        if ((line = findLineStartingWith(p.first)) != nullptr)
            p.second(p.first, line);
    }

    if (mIsSpectral) {
        if (mDataPointsPerLoop == -1)
            throw runtime_error("Invalid spectral data format (points per loop not found)");
    } else {
        if (mDataPointsPerLoop != -1)
            throw runtime_error("Invalid standard data format (points per loop found)");
        if (mPointsInFile == -1)
            throw runtime_error("Invalid standard data format (points in file not found)");
        mDataPointsPerLoop = 1;
    }
}

string* Metadata::findLineContaining(const string &target)
{
    for (auto& line : mRawMetadata)
        if (line.find(target) != string::npos)
            return &line;
    return nullptr;
}

string* Metadata::findLineStartingWith(const string &target)
{
    for (auto& line : mRawMetadata)
        if (line.find(target) == 0)
            return &line;
    return nullptr;
}

void Metadata::setPointsInFile(int pointsInFile)
{
	mPointsInFile = pointsInFile;

	const string dpInFileStarter = "#datapoints_in_file\t";

	string* pointsInFileLine = findLineStartingWith(dpInFileStarter);
	if (pointsInFileLine == nullptr)
		return;

	*pointsInFileLine = dpInFileStarter + to_string(pointsInFile);
}

TEKARI_NAMESPACE_END