#include "tekari/Metadata.h"

#include <sstream>
#include <vector>
#include <utility>
#include <functional>

TEKARI_NAMESPACE_BEGIN

using namespace std;

Metadata::Metadata()
:   mIsSpectralData(false)
,   mInPhi(0.0f)
,   mInTheta(0.0f)
,   mSampleName("Untilted")
,   mPointsInFile(-1)
,   mDataPointsPerLoop(-1)
{}

void Metadata::addLine(const string& line)
{
    mRawMetaData.push_back(line);
}

void Metadata::initInfos()
{
    const string* line;

    mIsSpectralData = findLineStartingWith("#spectral data generated by") != nullptr;

    vector<pair<string, function<void(const string&, const string*)>>> parsingFuncs =
    {
        make_pair("#number of datapoints per loop in file:", [this](const string &keyword, const string* line) {
            sscanf(line->c_str() + keyword.length(), "%d", &mDataPointsPerLoop);
        }),
        make_pair("#inphi", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInPhi); }),
        make_pair("#phi_in", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInPhi); }),
        make_pair("#intheta", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInTheta); }),
        make_pair("#theta_in", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%f", &mInTheta); }),
        make_pair("#datapoints_in_file", [this](const string &keyword, const string* line) { sscanf(line->c_str() + keyword.length(), "%d", &mPointsInFile); }),
        make_pair("#sample_name", [this](const string &, const string* line) { mSampleName = stripQuoteMarks(line->substr(13)); }),
    };

    for (const auto& p : parsingFuncs)
    {
        if ((line = findLineStartingWith(p.first)) != nullptr)
            p.second(p.first, line);
    }

    if (mIsSpectralData) {
        if (mDataPointsPerLoop == -1)
            throw runtime_error("Invalid spectral data format (points per loop not found)");
    } else {
        if (mDataPointsPerLoop != -1)
            throw runtime_error("Invalid standard data format (points per loop found)");
        if (mPointsInFile == -1)
            throw runtime_error("Invalid standard data format (points in file not found)");
        mDataPointsPerLoop = 1;
    }
}

string Metadata::toString() const
{
    ostringstream result;
    for (const auto& line : mRawMetaData)
        result << line << '\n';
    return result.str();
}

const string* Metadata::findLineContaining(const string &target) const
{
    for (const auto& line : mRawMetaData)
        if (line.find(target) != string::npos)
            return &line;
    return nullptr;
}

const string* Metadata::findLineStartingWith(const string &target) const
{
    for (const auto& line : mRawMetaData)
        if (line.find(target) == 0)
            return &line;
    return nullptr;
}

TEKARI_NAMESPACE_END